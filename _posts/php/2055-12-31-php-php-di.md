---
title: Библиотека php-di
description: >-
  Библиотека php-di
author: alex
date: 2055-12-31 20:30:00 +0300
categories: [Php, Libraries]
tags: [php]
image:
  path: /assets/img/posts/php1.png
  alt: Контейнер внедрения зависимостей в php
---

В предыдущей статье [https://lexusalex.site/posts/php-dependency-injection-container/](https://lexusalex.site/posts/php-dependency-injection-container/) мы поняли что такое контейнер внедрения зависимостей, разобрали где он может быть полезен. 

Сегодня на примере библиотеки [https://php-di.org/](https://php-di.org/)
посмотрим на практике, как использовать в реальном контейнер внедрения зависимостей. 

## Абстрактный пример

Допустим у нас есть абстрактный код где мы не используем контейнер, пусть это будет подсчет скидок в интернет магазине.

Как примерно может работать вызов функций:

````text
Приложение()
    Товары пользователя()
        Цены на товары()
            Доступна ли скидка()
                Расчет скидки()
                    Итоговый подсчет цены на товары()
````

То есть у нас зависимые функции, мы должны их создать и вызвать перед использованием другой функции.

Теперь как это может работать с использованием контейнера.

Определяем в контейнере все функции (допустим определили)

Вызываем `$container->get(Приложние())`

Что происходит за кадром. Так как для работы функции `Приложение()` нужны другие функции, контейнер сам позаботиться о вызове других зависимых функций, то есть функции

````text
Итоговый подсчет цены на товары()
Расчет скидки()
Доступна ли скидка()
Цены на товары()
Товары пользователя()
````

Будут вызваны тогда, когда они потребуются другой функцией. И об этом позаботится **контейнер php-di**.

## Установка

Ставим стандартным образом через `composer`.

````shell
# На текущий момент (октябрь 2024) актуальная версия 7.0.7
composer require php-di/php-di
````

## Базовое использование

Чтобы начать использовать `php-di` нужно создать класс и передать туда зависимости, к примеру так:

````php
$container = new Container([
    'depend1' => [1], // Зависимость 1
    'depend2' => function (\Psr\Container\ContainerInterface $c) { // Зависимость 2
       return $c->get('depend1'); // 2 зависимость зависит от первой
    }
]);

print_r($container->get('depend2')); // Достав первую зависисмоть получаем [1]
````

Применим эти знания к абстрактному примеру выше.

````php
$container = new Container([
    'application' => function (ContainerInterface $c) {
        print_r("подсчет товаров \n");
        return $c->get("goods");
    },
    'goods' => function (ContainerInterface $c) {
        print_r("подсчет цен\n");
        return $c->get("prices");
    },
    'prices' => function (ContainerInterface $c) {
        print_r("скидка\n");
        return $c->get("checkDiscount");
    },
    'checkDiscount' => function (ContainerInterface $c) {
        print_r("подсчет скидки\n");
        return $c->get("calculateDiscount");
    },
    'calculateDiscount' => function (ContainerInterface $c) {
        print_r("итоговый результат\n");
        return $c->get("result");
    },
    'result' => "result\n"

]);
print_r($container->get('application'));
/**
подсчет товаров 
подсчет цен
скидка
подсчет скидки
итоговый результат
result
 */
````

Мы определили все зависимости, достали из контейнера `application`, которая по цепочке вызывает все остальные зависимости.

Получаем линейный код, над которым мы имеем полный контроль.

Еще один пример. Допустим есть набор классов:

````php
Class One
{
    public function __construct(){
        echo "One";
    }
}

Class Two
{
    public function __construct(){
        (new One());
        echo "Two";
    }
}

Class Three
{
    public function __construct(){
        (new Two());
        echo "Three";
    }
}

$container = new DI\Container([
    Three::class => function($container){new Three();}
]);

$container->get(Three::class); // OneTwoThree
````

В контейнере определили последний класс, который подключит все зависимые классы.

## Методы контейнера

Контейнер реализует стандарт `PSR-11`. По стандарту доступны методы

- `get(id)` - Получить зависимость по id
- `has(id)` - Проверить существует зависимость по id

Плюс к этому доступны еще несколько методов



## Зависимости




````php
class Header
{
   public function __construct()
   {
     echo "Header";
   }
}

class Footer
{
    public function __construct()
    {
        echo "Footer";
    }
}

class Main
{
    public function __construct(Header $header, DivMain $divMain, Footer $footer){

    }
}

class DivMain
{
    public function __construct()
    {
        echo "Div Main";
    }
}

class Index
{
   public function __construct(Main $main){
       
   }
}

$builder = new \DI\ContainerBuilder();
$builder->addDefinitions([
    Header::class => static function (){return new Header();},
    DivMain::class => static function (){return new DivMain();},
    Footer::class => static function (){return new Footer();},
    Main::class => static function (ContainerInterface $container){
        return new Main($container->get(Header::class),$container->get(DivMain::class), $container->get(Footer::class));
    },
    Index::class => static function (ContainerInterface $container){
        return new Index($container->get(Main::class));
    }

]);

$build = $builder->build();


print_r($build->get(Index::class));
````

https://habr.com/ru/articles/327746/
https://github.com/codedokode/pasta/blob/master/arch/di.md
