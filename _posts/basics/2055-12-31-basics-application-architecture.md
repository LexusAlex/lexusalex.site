---
title: Архитектура приложений
description: >-
  Принципы построение приложений и сервисов любой сложности
author: alex
date: 2055-12-31 18:00:00 +0300
categories: [Basics]
tags: [application architecture]
---
 
Приложение -> Модуль -> Компонент

Основное

- Приложение
  - Само приложение
- Модуль
  - user
  - blog
  - authentication
  - authorization
  - oauth
- Компоненты
  - Service
    - Controller
      - Repository

Связи

- Внутренние - взаимодействие с внутренними сервисами
- Внешние - взаимодействие со внешними системами http rmq db

## DTO

Data Transfer Object
структура таблиц базы данных

Два приложения

- api приложение
  - api модуль
    - controller обработка запросов
      - service сохранение результата
- converter
  - app
    - app controller
      - service

## Монолит

Единое приложение для всего.
Обновить большое приложение становится сложным из-за легаси кода.

### Плюсы
 
На старте приложения.

- Простая разработка
- Простое тестирование
- Простая выкладка
- Масштабирование

### Минусы

- сложный пусть от соммита до релиза
- медленная сборка
- горизонтальное масштабирование требует ресурсов
- устаревающий стек и запутанность кода

Путь становится все длиннее и длиннее

lint -> build -> test deploy -> test -> deploy

## Микросервис

Несколько приложений

### Плюсы

- Быстрая сборка
- Горизонтальное масштабирование
- Возможность частичное смены или обновление стека
- Быстрый путь от коммита до релиза
- Высокая отказоусточивость
- Простая поддержка
- Деплоим независимые части

### Минусы

- Сложная декомпозиция системы
- Сложная выкладка и обновление и это не просто
- Другой подход к консистентности
- Усложненное логирование
- Жесткая поддержка контрактов

В большинстве монолит будет достаточно

## Модульный монолит

## Масштабирование проекта

Если сайт растет нужно наращивать мощности

- Балансировка нагрузки
  - Несколько копий монолитов можно определять по типу запроса например
- Масштабирование по функциям и нагрузке

## Декомпозиция системы

Сервис - это отдельное независимо разворачиваемое приложение, которое выполняет необходимый функционал

Например отправка email

- Слабая связанность между сервисами
- Стабильные контракты взаимодействия

Если мы правильно поделили сервисы это упростит работу с ним в будущем

Подходы

- По бизнес задачам (Сервис пользователей, Сервис расчетов)
- По доменной модели - замкнутая область знаний бизнес системы (Продавцы и покупатели)
- По командам
 
Не нужно делить каждую функциональность на отдельные микросервисы.

### Взаимодествия с сервисом

- Команды - меняет состояние сервиса, создать пост
- Запрос - получает данные , 10 последних постов
- Генерация событий

### Как декомпозировать

Доменная область - Область деятельности приложения
Ограничитель контекста - граница между доменами

- Выделение пользовательского сценария - основные use cases, нужно понимать задачи системы
  - Я как ученик хочу зарегистрироваться, чтобы купить курс
  - Я как пользователь хочу зарегистрироваться и зайти на сайт
  - Я как администратор хочу редактировать пользователей, чтобы следить за ними 
  - Нужно исходить из того как пользователь будет пользователя нашей системой
- Блоки функционала и блоки и связи между ними , важно понимать близость обьектов между ними
  - Ученик
  - Платежи
  - Курс
  - Пользователь
  - Файлы
  - Аутентификация
  - Авторизация
- Объединить блоки в сервисы
  - users
  - teachers
  - payments
  - blog
  - email
  - configurations
    - configuration
      - common
      - dev
      - test
    - error
    - router
    - migrations
    - validator
- Минимизировать деление
  - Разнести все вынесенные группы в максимально большие группы

## Монорепозиторий

- Переиспользование кода
- Удобная работа с контрактами
- Централизация зависимостей

Если нет, то можно независимо обновлять компоненты

## Паттерны 

- Repository - методы для работы с моделью одна модель = один репозиторий
- Entity - это и есть сама сущность





