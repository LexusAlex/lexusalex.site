---
title: Архитектурные принципы
description: >-
  Какими принципами руководствоваться при разработке проектов
author: alex
date: 2055-12-31 18:00:00 +0300
categories: [Basics]
tags: [architecture,solid,grasp,gof]
---

Разберем некоторые принципы, которые стоит принимать во внимание при разработке проектов, чтобы не было мучительно больно в будущем.

## Зачем это нужно

Сначала мы писали примитивные программы, потом добавили условия и циклы в одну простыню кода.

Поняли, что надо разделить код на процедуры, чтобы было удобнее их переиспользовать.

Так же - это дает некую абстракцию.

Но программа может быть большой, для его корректной поддержки в будущем нужно приложить усилие.

Не нужно делать абы как и писать одной простыней.

Сложность растет со временем жизни проекта и с размером программы.

Пишем программу и потом несколько лет ее поддерживаем и развиваем.

Реальные программы для клиентов всегда сложнее, поэтому баги будут возникать.

Чтобы проверить, что ваш код работает, нужно писать тесты и строго типизировать код.

Нет уверенности, что сейчас проект работает на 100%.

Удобно ли дописывать новую функциональность в текущий код, легкость доработки.

Бегаем по проекту, меняем в 10 местах, и если нет тестов, становится страшно.

Не факт, что для существующего проекта получится написать тесты.

Сначала время на тесты растет, но потом все получатся существенная экономия в ресурсах и времени.

Каша в проекте, ломается при любом соприкосновении с кодом.

Покрывать тестами в легаси коде важные вещи с начала.

## SOLID

Со временем у программистов накопился опыт написания программ.
В какой-то момент появились вопросы что вам мешает писать код, и что помогает писать код.

Баги в проекте может возникнуть из-за того что мы лезем в код.

Причины проблем:

1. Изменение существующего кода, влечет ошибки.
2. Лишние связи в сущностях или в функциях.

В системе могут быть хаотичные связи, а есть системы с аккуратными связями, к этому надо стремиться.

Ключевая идея принципов, нужно написать код, который победит проблемы выше.

Хаотическое возникновение багов ведет к долгой разработке.

Чтобы этого не было были сформулированы ряд принципов.

### SRP

Single Responsibility principle
Принцип единственной ответственности

Много кода в одном месте

Разные группы людей, одна программная система, либо один класс

Директор - у нас есть два способа оплаты - добавь еще один
Нужно поменять код во многих местах

Бухгалтер - добавить выдачу двух кассовых чеков, а сейчас один
Нужно поменять код во многих местах

Финансовый аналитик - нужна статистика для аналитики, по заказам
Нужно поменять код во многих местах

Код смешенный, и неудобный, 8000 тыс строк кода в одном классе.

Меняем код на каждую хотелку, чем больше мест чем больше ошибок.

Чтобы проблем не было, нужно с самого начала программировать систему так, чтобы она была модульной по ролям

Например, можно выделить модули

- Бухгалтерия - свой набор классов
- Статистика - свой набор классов
- Аналистика - свой набор классов
- Блог - свой набор классов

Нужно делать так, чтобы связей было как можно меньше.

Разные фронтенды для разных ролей.

По разным требованиям, правим разные файлы.

Мы меняем код в одном месте, риск что-то сломать меньше.
Нужно менять максимально маленькие участки кода.
Каждый участок кода, меняем только по запросу от конкретного актора

Не будет хаоса, не будет что непонятно что менять, куда лезть.

Меняем только ограниченный участки кода.
Один класс должен быть изменен по инициативе от одного актора

Пользователь один, данные от него храним в разных таблицах

````text
[5,123]
[5,567]
[5,Банкрот]
[5,Вася]
````

Нужно как можно меньше править уже работающий код.

Нужно делить функционал на разные части, делить на разные классы, не лепить все вс один

````php
final class Client
{
  public function __construct() {
      private array $providers;
  }
  
  public function generate() {
    foreach ($this->providers as $provider) {
        return $provider->url();
    }  
  }
}
````

Если делать все так нам не нужно менять старый код, в идеале нужно создать новый класс.

class
test

Но лучше больше классов

class1
test1
class2
test2
class3
test3

Этот паттерн называется proxy. Всю инфраструктуру вынесли в отдельный класс, и каждому классу тест

Изменяемый код выносим в отдельные классы, который часто меняется
Нужно использовать делегирование, а не наследование, так удобнее менять составные части.

Проблемы наследования - любое изменение в родительском классе ломает все места в дочернем классе

Остальные классы мы не трогаем, а просто меняем уже существующие

Новый код не трогает старый код.

### OCP

open–closed principle
Принцип открытости/закрытости

Свободные для расширения, но закрыты для изменения.

LSP

Liskov Substitution Principle
Принцип подстановки Лисков

Если есть базовый тип, то все его подттипы, должны вести себя так же как же как и базовый
Применимо к классам и интерфейсам.


ISP

interface segregation principle
Принцип разделения интерфейса

````php
interface Router 
{
    public function matchRequest($request): array 
    {
    
    }
}

class FastRouterAdapter implements Router
{

}

new App($router);

$response = $app->handle($request);

class BlogContoller {
    
    public function index() {
    
    }
}
    
}
````

4.41

DIP

Все принципы работают, чтобы уменьшить связанность кода и его изменение

GRASP

Общие паттерны

1. Информационный эксперт (Information Expert)2
2. Создатель (Creator)
3. Контроллер (Controller)
4. Слабое (низкое) зацепление (Low Coupling) 
5. Сильная (высокая) связность (High Cohesion) 
6. Полиморфизм (Polymorphism) 
7. Чистая выдумка (Pure Fabrication) 
8. Перенаправление (Indirection) 
9. Устойчивость к изменениям (Protected Variations)

goF
