---
title: Регулярные выражения
description: >-
  Постепенно разберемся как работают регулярные выражения перейдем на реальных примерах
  от простого к сложному 
author: alex
date: 2055-06-02 09:00:00 +0300
categories: [Basics,Regexp]
tags: [regular expression]
image:
  path: /assets/img/posts/regexp.png
  alt: Регулярные выражения.
---

## Вместо введения

Регулярные выражения (Regexp) - это мощный и эффективный инструмент для работы с текстом.
Само по себе регулярное выражение предназначено для решения конкретных задач поиска или замены информации.

Регулярное выражение - это символьные стоки, предназначенные для сопоставления с текстом и манипулирования им.

## Базовый вариант

Базовый вариант регулярных выражений это простой поиск текста, где символы соответствуют сами себе, за исключением специальных символов. 

По умолчанию мы ищем только одно вхождение при этом регистр букв важен.

Например:

- регулярное выражение: `a`
- строка поиска и результат: <span style="background-color:#7AE;color:white">а</span>ааааааа

или

- регулярное выражение: `Алексей`
- строка поиска и результат: Привет, мое имя <span style="background-color:#7AE;color:white">Алексей</span>. Привет, мое имя Алексей

### Поиск части слова

Или же поиск по части слова:

- регулярное выражение: `ве`
- строка поиска и результат: При<span style="background-color:#7AE;color:white">ве</span>т

## Разделитель

Само регулярное выражение состоит из строки-шаблона. В роли ограничителей например могут выступать символы:

````text
/
~
@
;
%
#
````

Пример регулярного выражения с разделителем:
 
- регулярное выражение: `/строка/`
- строка поиска и результат: Тестовая <span style="background-color:#7AE;color:white">строка</span>

### Пример с разделителем и модификатором

Теперь представим есть строка **телефоны и на телефоне и не тот телефон**, нужно найти все вхождения слова _телефон_:

- регулярное выражение: `/телефон/`
- строка поиска и результат: <span style="background-color:#7AE;color:white">телефон</span>ы и на телефоне и не тот телефон

Но мы найдем только первое вхождение.

Для того чтобы найти все вхождения с регулярным выражением нужно применить модификатор `g`, что значит глобальный поиск по всей строке.

Модификаторы указываются после разделителя в конце:

- регулярное выражение: `/телефон/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">телефон</span>ы и на <span style="background-color:#7AE;color:white">телефон</span>е и не тот <span style="background-color:#7AE;color:white">телефон</span>

> Модификаторы или флаги модифицируют поведение регулярного выражения
{: .prompt-info }

Уже кое-что, но этого мало, ведь гибкость регулярных выражений раскрывается когда 
мы работаем с символьными классами.

## Символ точка

`.` - это специальный символ, совпадение с любым одиночным символом кроме пробельного.

- регулярное выражение: `/ca./g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">cat</span> <span style="background-color:#7AE;color:white">car</span>

То есть на месте `.` может быть любой символ.

Еще пример:

- регулярное выражение: `/file./g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">file1</span>.xls <span style="background-color:#7AE;color:white">file2</span>.xls <span style="background-color:#7AE;color:white">file3</span>.xls na1.xls na2.xls

Тут мы ищем имена файлов `file` и в конце ставим точку как любой символ, в итоге нашли 3 файла

> Важно помнить, что с шаблоном регулярного выражения совпадают не целые строки, а только отдельные символы из строки.
{: .prompt-info }

Точку можно применять в любом месте несколько раз.

Вот такой пример без глобального флага `g`: 

- регулярное выражение: `/.../`
- строка поиска и результат: <span style="background-color:#7AE;color:white">соб</span>ака

То есть любые три символа как раз попали.

Если нужно найти саму точку в строке, символ `.` нужно экранировать.

- регулярное выражение: `/file.\.xls/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">file1.xls</span> <span style="background-color:#7AE;color:white">file2.xls</span> <span style="background-color:#7AE;color:white">file3.xls</span> na1.xls na2.xls

Вот теперь попала точка + мы добавили расширение `.xls`

> Символ `\` всегда обозначает начало экранирования символов, например сам `\` экранируем так `\\`
{: .prompt-info }

## Про экранирование

Чуть выше я писал, что специальные символы если они совпадают с обычными нужно экранировать. 

Метасимвол - это символ, который имеет специальное назначение.

Например, это символы `.\[]{}*`

- регулярное выражение: `/\[1\]/g`
- строка поиска и результат: $test = <span style="background-color:#7AE;color:white">[1]</span>

В примере выше мы экранировали специальные символы `[]`, чтобы найти значение в квадратных скобках.

## Символьные классы

Символьный класс - это комбинация символов определенного набора в квадратных скобках.

К примеру найдем возможные окончания строки **телефон**:

- регулярное выражение: `/телефон[еы]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">телефоны</span> и на <span style="background-color:#7AE;color:white">телефоне</span> и не тот телефон

Но как найти просто **телефон**. Как сказать что символы символьного класса могут быть, а могут и не быть. 
Для этого существует квантификатор `?`. 

> Квантификатор - это ограничитель, который контролирует количество возможных повторений символов или класса символов
{: .prompt-info }

О квантификаторах поговорим ниже.

Для примера выше добавим его после символьного класса добавим квантификатор `?`.

- регулярное выражение: `/телефон[еы]?/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">телефоны</span> и на <span style="background-color:#7AE;color:white">телефоне</span> и не тот <span style="background-color:#7AE;color:white">телефон</span>

Теперь нашли все возможные варианты.

### Пример с поиском всех слов в строке
 
Еще пример, имеем последовательность **рай сад май вай Кай Сад**.
Задача найти все слова. Просто перечислим все нужные нам буквы.

- регулярное выражение: `/[КСвмсрайд]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">рай</span> <span style="background-color:#7AE;color:white">сад</span> <span style="background-color:#7AE;color:white">май</span> <span style="background-color:#7AE;color:white">вай</span> <span style="background-color:#7AE;color:white">Кай</span> <span style="background-color:#7AE;color:white">Сад</span>

Можно конечно указать нужные буквы так `/[абвгдеёжзийклмнопрст]/`, но так никто не делает, есть способ проще.

### Диапазон символов

Укажем диапазоны символов:

- `[а-я]`
- `[А-Я]`
- `[a-z]`
- `[A-Z]`
- `[0-9]` - что эквивалентно `[0123456789]`

Либо сразу все символы: 

- `[a-zA-Zа-яА-Я0-9]`

> Избегайте ошибок указания диапазона значений меньше начала, например `[9-1]`
{: .prompt-info }

> Символьные классы могут быть в любом месте выражения.
{: .prompt-info }

#### Пример с поиском всех слов

С помощью символьных классов найдем все слова в строке **договор договоры договора**, Но при этом не перечисляя весь алфавит, а только нужные нам буквы.

- регулярное выражение: `/[а-до-ры]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">договор</span> <span style="background-color:#7AE;color:white">договоры</span> <span style="background-color:#7AE;color:white">договора</span>

#### Пример с поиском определенного символа

Но чаще мы ищем не все слова, а только определенные слова и символы в тексте.

Например, нужно найти в тексте символ `,` и предшествующие ему определенные буквы:

- регулярное выражение: `/[авх],/g`
- строка поиска и результат: это тем<span style="background-color:#7AE;color:white">а,</span> которая привлекает внимание многих исследователей и специалистов в различных областях. Этот загадочный объект представляет интерес для астрономо<span style="background-color:#7AE;color:white">в,</span> физико<span style="background-color:#7AE;color:white">в,</span> биологов и других учены<span style="background-color:#7AE;color:white">х,</span> но также сопряжен с рядом подводных камней и опасностей. Давайте ближе рассмотрим некоторые из них

> Внутри могут быть литералы, которые меняют поведение символьного класса.
{: .prompt-info }

#### Отрицание

Иногда требуется найти символы кроме указанных в символьном классе.
Делается это с помощью символа `^`.

Например:

````text
[^а-и] - любой символ кроме указанного диапазона
[^А-Яа-яa-zA-Y0-9] - символы кроме указанных диапазонов
````

Посмотрим на пример с отрицанием:

- регулярное выражение: `/[^А-Яа-яa-zA-Y0-9]/g`
- строка поиска и результат: sdfgdfg<span style="background-color:#7AE;color:white">Z-!.</span>78абвг<span style="background-color:#7AE;color:white">,?</span>

Мы нашли все кроме всех указанных диапазонов. Что не попало в отрицание поиска - это символы `Z-!.,?`
 
Еще пример:

- регулярное выражение: `/file[13].xls/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">file1.xls</span> file2.xls <span style="background-color:#7AE;color:white">file3.xls</span> na1.xls na2.xls
 
Нашли, только `file1` и `file3`.

> Символ `^` обозначает отрицание всех символов в наборе, а не только первого символа идущего за ним.
{: .prompt-info } 

#### Поиск символа - (дефис)

Символ дефиса используется как указатель диапазона искомых символов `[0-9]`.
Но как его найти в тексте?

Для этого его нужно указать в начале или в конце символьного класса, при этом его совсем не обязательно экранировать, например:

- регулярное выражение: `/[-0-9]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">-123454</span>

Или в конце класса, результат от этого не поменяется:

- регулярное выражение: `/[0-9-]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">-123454</span>

#### Поиск других символов

Другие символы - это не буквы и не цифры можно найти тем же образом, перечислив их.

- регулярное выражение: `/[,.!~><()=+]/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">,.!~><()=+</span>

#### Предопределенные символьные классы

Помимо формы в квадратных скобках существует также краткая форма их записи:

````text
\d - целое число [0-9]
\D - символ кроме целого числа [^0-9]
\s - Пробельный символ [\f\n\r\t\v ]
\S - Символ кроме пробельного [^\f\n\r\t\v ]
\w - Буква,цифра и нижнее подчеркивание [a-zA-Z0-9_]
\W - Любой символ кроме буквы,цифры и нижнего подчеркивания [^a-zA-Z0-9_]
````

Рассмотрим примеры.

##### Целое число

Найдем все числа и дефис в тексте: 

- регулярное выражение: `/\d\d\d-/g`
- строка поиска и результат: номер <span style="background-color:#7AE;color:white">123-</span>

Как видим выглядит уже лучше, чем мы бы писали так `/[0-9][0-9][0-9]-/g`. Результат тот же.

##### Все кроме чисел

Если нужно найти все кроме чисел пишем `\D`

- регулярное выражение: `/\D/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст</span> 78 <span style="background-color:#7AE;color:white">вместе</span> 9 <span style="background-color:#7AE;color:white">с</span> <span style="background-color:#7AE;color:white">числами</span> 123<span style="background-color:#7AE;color:white">!</span>

##### Пробельный символ
 
Далее нужно понять что такое пробельный символ

> В пробельные символы входят
> - ` ` пробел
> - `\r` возврат каретки (CR)
> - `\n` перевод строки (LF)
> - `\t` табуляция
> - `\v` вертикальная табуляция
> - `\f` конец страницы
{: .prompt-info }

> Для разных операционных систем окончания строк разные, например для windows это `\r\n` а для linux и macos это `\n`  
{: .prompt-info }

- регулярное выражение: `/\s/g`
- строка поиска и результат: много<span style="background-color:#7AE;color:white">  </span>пробелов<span style="background-color:#7AE;color:white"></span>еще<span style="background-color:#7AE;color:white"> </span>и<span style="background-color:#7AE;color:white"> </span>с<span style="background-color:#7AE;color:white"> </span>переносом<span style="background-color:#7AE;color:white"> </span>строки

##### Кроме пробельных символов

Обратная ситуация когда нам наоборот не нужны пробелы

- регулярное выражение: `/\S/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст</span> <span style="background-color:#7AE;color:white">с</span>   <span style="background-color:#7AE;color:white">пробелами</span> <span style="background-color:#7AE;color:white">123?</span>

#####  Латинские буквы и цифры

Существует так же команда под которую подходят буквы, цифры и нижнее подчеркивание.

- регулярное выражение: `/\w/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">Stay</span> <span style="background-color:#7AE;color:white">go</span> <span style="background-color:#7AE;color:white">home123</span> Русский текст

#####  Латинские не буквы и цифры

И обратная ситуация, когда попадет все кроме букв и цифр

Пример тот же, что и выше

- регулярное выражение: `/\W/g`
- строка поиска и результат: Stay<span style="background-color:#7AE;color:white"> </span>go<span style="background-color:#7AE;color:white"> </span>home123<span style="background-color:#7AE;color:white"> Русский текст</span>

### Кратко про символьные классы

## Квантификаторы

Квантификатор - это специальный ограничитель, который указывает на возможное кол-во повторений символа или символов перед ним.

### ?

`?` - означает, что символ или символы перед `?` могут быть ноль или один раз.

Простой пример:

- регулярное выражение: `/кто?/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">кто</span>о
- строка поиска и результат: <span style="background-color:#7AE;color:white">кто</span>
- строка поиска и результат: <span style="background-color:#7AE;color:white">кт</span>

Здесь подразумевается, что буква `o` может быть либо 0 или 1 раз, но не больше.

Еще пример:

- регулярное выражение: `/текст[0-9]?/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст</span>
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст8</span>
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст8</span>678

Здесь уже у нас символьный класс `[0-9]` и мы проверяем его наличие или отсутствие.

`?` У нас значит ноль или один раз.
 
Еще пример, протокол `http`

- регулярное выражение: `/https?/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">http</span> <span style="background-color:#7AE;color:white">https</span>

Буква `s` может быть, а может и не быть.

### +

`+` - последовательность символов (или набора) должна повторятся один или более раз

К примеру 

- регулярное выражение: `/текст[0-9]+/g`
- строка поиска и результат: текст
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст7777777</span>
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст7777777</span>,...7

Ключевое отличие `+` от `?` что обязательно должен быть один раз или более.

> Знак `+` как и другие в этом разделе является мета символом. Если нужно найти совпадение непосредственно со знаком `+` нужно его экранировать `\+`
{: .prompt-info }

Распространенный пример `[\w.]+` дает возможность совпасть нескольким символам, а именно `[a-zA-Z0-9.]`.

Обратите внимание, что регулярное выражение `/\w.+/`, дает получить любые символы от 1 и более раз.

### *

`*` - символ может встречаться ноль или более раз.

Самый сильный квантификатор.

- регулярное выражение: `/текст[0-9]*/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст</span>
- строка поиска и результат: <span style="background-color:#7AE;color:white">текст77777</span>

> Мета символ `*` можно рассматривать, как нечто необязательное
{: .prompt-info }

### Диапазон повторений

Мета символы `+*` обеспечивают совпадение с неограниченным количеством символов. Они не позволяют задать минимальное количество совпадений.
 
Ситуацию исправят интервалы или диапазоны повторений. Когда требуется указать количество раз, сколько последовательность может повториться. 

> Сам интервал заключается в {}, эти символы сами являются мета символами и должны быть экранированы, чтобы использоваться как обычные символы
{: .prompt-info }

### {0}

Указываем точную цифру сколько нужно повторять последовательность.

Примеры:

- `{1}`
- `{4}`
- `{16}`

- регулярное выражение: `/[0-9]{5}/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">12345</span>6789 

Символы будут повториться ровно 5 раз.

- регулярное выражение: `/h{13}/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">hhhhhhhhhhhhh</span>hhhhhhh

Как видим, мы ожидаем 13 символов.

### {0,}

Символы будут повториться не менее указанных раз 

- регулярное выражение: `/[0-9]{5,}/g`
- строка поиска и результат: 1234
- строка поиска и результат: <span style="background-color:#7AE;color:white">12345678910</span>

В данных примерах символов должно быть или 5 или больше 5, но не меньше 5

### {0,1}

Символы повторятся от и до раз. От минимального до максимального


- регулярное выражение: `/[0-9]{3,8}/g`
- строка поиска и результат: 12
  <span style="background-color:#7AE;color:white">123
  12345678
  12345678</span>9

 Строго от 3 до 8 символов.

> Квантификатор {0,1} на самом деле эквивалент ?
> Квантификатор {1,} на самом деле эквивалент +
> Квантификатор {0,} на самом деле эквивалент *
{: .prompt-info }


### Примеры

#### Первый

- регулярное выражение: `/\d\d\d\d\d\d\d\d\d/`
- строка поиска и результат: <span style="background-color:#7AE;color:white">123456789</span>

Согласитесь решение не красивое, сократим его указав `+`

- регулярное выражение: `/\d+/`
- строка поиска и результат: <span style="background-color:#7AE;color:white">123456789</span>

Вот теперь гораздо лучше

#### Второй

- регулярное выражение: `/\d+-\d+-\d+/g`
- строка поиска и результат: 123456789 <span style="background-color:#7AE;color:white">123-1234-123</span>

Вот теперь первый номер не попал в наше поле зрения. Поправим поставим `?` после дефиса.

- регулярное выражение: `/\d+-?\d+-?\d+/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">123456789 123-1234-123</span>

#### Третий

- регулярное выражение: `/\d+[- (]?\d+[- )]?\d+/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">123456789
  123-1234-123
  8(123)123123
  8 345 123456</span>

Здесь мы заменили дефисы на символьные классы

#### Четвертый

- регулярное выражение: `/\+?\d+[- (]?\d+[- )]?\d+/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">123456789
  123-1234-123
  8(123)123123
  8 345 123456
  +6 889 90000</span>

Нашли еще телефон с `+` добавив его присутствие или отсутствие с помощью экранирования.

#### Пятый

У нас есть некий html

````html
<p>Текст в параграфе1</p>     <p>Текст в параграфе2</p>
````

Нужно найти полностью тег `p`

- регулярное выражение: `/<[p]>.*?\/[p]>/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white"><p>Текст в параграфе1</p></span>     <span style="background-color:#7AE;color:white"><p>Текст в параграфе2</p></span>

https://habr.com/ru/articles/545150/
http://sajgak.ru/site/php/shpargalka-regularnie-virageniya-pcre/
https://devanych.ru/technologies/shpargalka-po-regulyarnym-vyrazheniyam
https://ru.hexlet.io/courses/regexp/lessons/symbols/theory_unit  

## Граница слова

### Мета символ \b

Часть бывает нужно обозначить границу слова, чтобы поиск был не слова в составе другого слова, а слова целиком.

К примеру:

- регулярное выражение: `/\bтест\b/gu`
- строка поиска и результат: тестовая строка <span style="background-color:#7AE;color:white">тест</span> еще <span style="background-color:#7AE;color:white">тест</span>, но много тестов
 
Заметим что слова `тестовая` и `тестов` мы не нашли, так как это не отдельные слова

> Модификатор `/u` значит, что поиск будет идти по всей таблице unicode  
{: .prompt-info }

> Мета символ \b, просто обеспечивает совпадение с местоположением в промежутке между символами. Следовательно, должен быть использован, как до искомого слова, так и после него.
{: .prompt-info }

- регулярное выражение: `/\bтест/gu`
- строка поиска и результат: <span style="background-color:#7AE;color:white">тест</span>овая строка <span style="background-color:#7AE;color:white">тест</span> еще <span style="background-color:#7AE;color:white">тест</span>, но много <span style="background-color:#7AE;color:white">тест</span>ов

В примере у нас совпали все слова начинающиеся на `тест`.

- регулярное выражение: `/тест\b/gu`
- строка поиска и результат: тестовая строка <span style="background-color:#7AE;color:white">тест</span> еще <span style="background-color:#7AE;color:white">тест</span>, но много тестов кон<span style="background-color:#7AE;color:white">тест</span>

А вот здесь обратная ситуация мы получили и сами слова `тест` и слова оканчивающееся на `тест`.

Если требуется точное совпадение со словом указываем `/bслово/b`

> Мета символ \b обеспечивает совпадение не с символом, а с позицией 
{: .prompt-info }

### Исключение совпадений \B

Если нужно наоборот исключить совпадение на границе слова, используется мета символ `\B`

- регулярное выражение: `/\B-\B/gu`
- строка поиска и результат: <span style="background-color:#7AE;color:white">-</span> +-слово слово-

В данном случае, мы нашли только первый дефис, так как он не находится на границах слова. 

## Граница символьных строк

Границы символьных строк нужны для сопоставления с шаблонами в начале или в конце целой строки.

### Начало строки ^

> Мета символ `^` имеет несколько значений. В символьных классах [] - это отрицание, если он указан за пределами набора символов - то это совпадение с началом символьной строки.
{: .prompt-info }

- регулярное выражение: `/^ма/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">ма</span>й или март

Как видно, совпало только слово с начала строки.

### Конец строки $

Аналогичная ситуация и для конца строки.

- регулярное выражение: `/ма$/g`
- строка поиска и результат: май или гамма ма<span style="background-color:#7AE;color:white">ма</span>

Бесполезный шаблон.

Шаблон `/^.*$/g` является бесполезным, так как находит все подряд.

Еще задача найти все комментарии в коде.

- регулярное выражение: `/(?m)^\s*\/\/.*$/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">// Комментарий</span>
  А это не комментарий
  <span style="background-color:#7AE;color:white">// Еще коммент </span>

Модификатор `m` в начале говорит и том, что мета символы `^` и `$` будут работать для каждой строки, а не всего выражения целиком.

Любой пробельный символ в начале строки может быть, а может и не быть `^\s*`.

> Модификатор (?m) поддерживается не всеми языками программирования, иногда его заменяет просто /m в конце регулярного выражения
{: .prompt-info }

> В некоторых реализациях регулярных выражений используются мета символы `\A` и `\Z` как аналоги  `^` и `$`
{: .prompt-info }

## Модификаторы

Модифицировать дефолтное поведение регулярных выражений можно с помощью флагов (модификаторов) они указываются после строки-шаблона.

Основные из них:

- `g` ищет все совпадения, а не только первое вхождение
- `i` регистронезависимый поиск
- `m` мультистроковость поиска
- `u` поддержка юникода

### /g - глобальный поиск

Находит все совпадения в строке

- регулярное выражение: `/тест/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">тест</span>овая строка <span style="background-color:#7AE;color:white">тест</span>, и еще <span style="background-color:#7AE;color:white">тест</span>

### /i - регистронезависимый поиск

## Группировка подвыражений

Чтобы дать понять, что данное выражение интерпретируется как единое целое, выражение заключают в скобки `()`.

`()` являются мета символами.

- регулярное выражение: `/([1-3][5-7])/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">16</span>

В примере выше мы сгруппировали символьные классы в большую группу.

Более показательный пример. Напишем регулярное выражение для поиска IP адресов.

В простейшем виде, оно выглядит следующим образом:

- регулярное выражение: `/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">1.2.3.444</span>

Это просто 4 группы из цифр в количестве от 1 до 3, разделенный точками.

Но выглядит не очень, много повторений, немного подкорректируем, обернем повторяющиеся часть в `()`:

- регулярное выражение: `/(\d{1,3}\.){3}\d{1,3}/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">1.2.3.444</span>

Этот вариант по сравнению с верхним идентичен, но короче.

> Для регулярных выражений характерна повторяемость символьных блоков, их нужно определять и заключать в `()`  
{: .prompt-info }

> Допустима практика, выделять все подвыражения в `()` для удобочитаемости. Хотя это не оказывает никакого эффекта на функциональность выражения. 
{: .prompt-info }

## Логическое ИЛИ

Так же может понадобиться выбрать из нескольких значений:

- регулярное выражение: `/(19|20|30)/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">30</span> <span style="background-color:#7AE;color:white">20</span> <span style="background-color:#7AE;color:white">19</span> 21 <span style="background-color:#7AE;color:white">19</span>

В примере выше, под шаблон попадает любое из 3 чисел, при этом это одна группа.

А теперь исходя из верхнего примера попробуем найти год,

- регулярное выражение: `/(19|20|30)\d{2}/g`
- строка поиска и результат: <span style="background-color:#7AE;color:white">1987</span>

Под это выражение попадают любые четырех значные года.

> Если перед нами сложное регулярное выражение с подвыражениями, его следует разбить на отдельные части и разбирать посимвольно.
{: .prompt-info }

## Позиционный просмотр

Иногда бывает нужно извлечь только нужные части совпадающего выражения. Для этого воспользуемся позиционным просмотром.

В выражении нужно указать `(?=)` и далее шаблон после которого нужно прокрутить вперед.

- регулярное выражение: `/(?=:).+/g`
- строка поиска и результат: http:<span style="background-color:#7AE;color:white">//site.ru</span>

Что тут получается, когда мы доходим до символа `:`, то что было до этого отрезается.

Однако, фактического совпадения со знаком `:` нет, метасимвол `(?=)` говорит механизму регулярных выражений обнаружить совпадение со знаком `:` и прокрутить выражение вперед.

## Как составить регулярное выражение

Разложить его на части

Например, номер телефона

> Главное в регулярном выражении понять, не совпадает ли шаблон с тем, что не нужно.
{: .prompt-info }

>  Регулярные выражения редко когда бывают верными и неверными. Чаще вес имеет степень строгости сопоставления с шаблоном.
{: .prompt-info }

## Примеры

Рассмотрим решение реальных примеров.
Возможно со временен соберем библиотеку регулярных выражений.

### Дата рождения

- регулярное выражение: `/(0?[1-9]|[12][0-9]|3[01]).(0?[1-9]|1[012]).((19|20)\d\d)/`
- строка поиска и результат: 
 

````text
/
    (
        0?
        [1-9]|[12]
        [0-9]|3[01]
    )
    .
    (
        0?
        [1-9]|1
        [012]
    )
    .
    (
        (19|20)
        \d\d
    )
/
````

### Ip адрес

- регулярное выражение: `/([0-9]{1,3}[\.]){3}[0-9]{1,3}/gm`

https://habr.com/ru/articles/349860/
https://habr.com/ru/articles/545150/
http://sajgak.ru/site/php/shpargalka-regularnie-virageniya-pcre/

https://www.youtube.com/watch?v=ozFNilK4qrc&t=1290s

https://regex101.com/

https://devanych.ru/technologies/shpargalka-po-regulyarnym-vyrazheniyam
