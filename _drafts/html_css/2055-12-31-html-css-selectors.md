---
title: Селекторы в css
description: >-
  Типы селекторов в css
author: alex
date: 2055-03-26 14:20:00 +0300
categories: [Css]
image:
  path: /assets/img/posts/main/css.jpeg
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Типы селекторов в css
---

**Селектор** - это такая структура, которая используется как условие определяющее каким элементам в дереве документа соответствует селектор.

Селекторы могут быть простыми или расширенными контекстными представлениями.

## Универсальный селектор *

Универсальный селектор `*` применяется ко всем элементам на странице.

### Пример 1. Размер шрифта для всего документа

````css
* {
    font-size: 20px;
}
````

````html
<p>Текст</p>
<b>Жирный текст</b>
<span>Просто текст</span>
````

В результате все элементы на странице будут размером `20px`

### Пример 2. Сброс отступов и полей для всех элементов

Сброс стилей по умолчанию используют для нормализации стилей браузера по умолчанию.

В примере элемент `body` и элементы `p` имеют отступы по умолчанию, данный стиль сбрасывает их в ноль.

````css
* {
  margin: 0;
  padding: 0;
}
````

````html
<p>Блок 1</p>
<p>Блок 2</p>
<p>Блок 3</p>
````

В итоге результат получается предсказуемым для дальнейшей стилизации.

### Пример 3. box-sizing для всех элементов

> Псевдоэлементы `::before и ::after` не включают универсальный селектор, поэтому их нужно перечислять отдельно
{: .prompt-info }

Данный стиль меняет алгоритм расчета размеров элемента. Что в будущем упрощает управление размерами элемента, так как ширина элемента не будет увеличиваться.

Наглядно посмотрим на пример

Имеем несколько элементов `p`.

````css
*,
*::before,
*::after {
  box-sizing: border-box;
}

p {
  padding: 20px;
  margin: 20px;
  width: 100px;
}
````

````html
<p class="one">Блок 1</p>
<p class="two">Блок 2</p>
<p class="three">Блок 3</p>
````
С помощью `javascript` выведем размеры элемента.

Без `box-sizing: border-box` ширина элемента составляла `140px`, а это `padding` с двух сторон.
С применением этого стиля ширина будет четко заданной, это `100px`.

````javascript
console.log(document.querySelector('.one').getBoundingClientRect().width); // 100
````

В итоге, мы имеем четкий размер который указали.

### Пример 4. Все элементы в рамках контекста

В рамках одного селектора, универсальный селектор можно использовать для действия внутри этого селектора.

Первое правило, цвет для всего элемента `p`. А второе это цвет для всех элементов внутри `p`.

````css
p {
  background-color: #0d6efd;
}
p * {
  background-color: #2bcc2b;
}
````

````html
<p>
    <small>small 1</small>
    <small>small 2</small>
    <b>b 1</b>
</p>
````

Получаем результат, стиль применяется только к элементам внутри `p`, не включая сам `p`

![Все элементы в рамках контекста](/assets/img/posts/css/selectors/universal.png){: .shadow }
_Все элементы в рамках контекста_

### Пример 5. Применение стиля к каждому следующему элементу, кроме первого

Мы привыкли писать стили для каждого отступа или каждого блока, тут есть шанс что-то упустить.
В случае с таким странным селектором отступ устанавливается в одну строку всем элементам в потоке, которые следуют за другим элементом в любых вариациях и в любом порядке.

````css
* + * {
  margin-top: 100px;
}
````

````html
<p>Первый</p>
<p>Второй</p>
<p>Третий</p>
<p>Четвертый</p>
````

Здесь в результате у нас только у каждого второго элемента в потоке будет верхний внешний отступ.

> Универсальный селектор следует использовать с осторожностью в связи с широким охватом
{: .prompt-info }

## Селектор элемента (тега) E

Селектор элемента соотносится с `html` элементам и находит их по имени тега. 

### Пример 1. Стиль для всех списков

В качестве примера рассмотрим списки `ul`.

````css
ul {
  background-color: #77AAEE;
}
````

С такой разметкой

````html
<ul>
    <li>Элемент списка 1</li>
</ul>
<div>
  Просто div
  <ul>
    <li>Элемент списка 2
      <ul>
        <li>Элемент списка 3</li>
      </ul>
    </li>
  </ul>
</div>
````

В результате стиль покрасили фон, применили ко всем элементам `ul` на странице.

![Селектор элемента](/assets/img/posts/css/selectors/tags.png){: .shadow }
_Селектор элемента_

### Пример 2. Применение стиля сразу для нескольких элементов

> Чаще всего этот селектор используют в начале файла, когда переопределяют встроенные стили браузера
{: .prompt-info }

Применяем селектор тега сразу для нескольких элементов

````css
h6, h5, h4, h3, h2, h1 {
  margin-top: 0;
  margin-bottom: 0.5rem;
  font-weight: 500;
}
````

````html
<h1>Заголовок 1</h1>
<h2>Заголовок 2</h2>
<h3>Заголовок 3</h3>
<h4>Заголовок 4</h4>
<h5>Заголовок 5</h5>
<h6>Заголовок 6</h6>
````

В итоге задаем некие стили по умолчанию, для всех элементов `h*` на странице.

### Пример 3. Последнее примененное правило

Представим у нас есть стили `css` для `h1`

````css
h1 {
  color: #77AAEE;
}

h1 {
  color: #e0ff76
}

h1 {
  color: burlywood;
}
````

И разметка

````html
<h1>Заголовок 1</h1>
````

Какой итоговый цвет `h1` будет?

Итоговый цвет `h1` будет `burlywood`, что это означает, что если для одного и того же элемента задано несколько правил, то применяется, то правило, которое указано последним.

Такой вот нюанс о котором нужно помнить.

> Использовать с осторожностью, так как селектор элемента применим ко всем элементам вне зависимости от уровня вложенности.
{: .prompt-info }

## Селектор по идентификатору (#)

**Идентификатор** - это уникальное имя элемента для всей страницы. Идентификатор в `html` указывается в атрибуте `id`. 

### Пример 1. Стиль для конкретного элемента

Базовый пример, стиль для конкретного элемента

````css
#block {
  background-color: #2bcc2b;
}
````

````html
<p id="block">123</p>
````

Результат очевиден, элемент будет найден по идентификатору и покрашен соответствующим цветом.

### Пример 2. Специфичность и идентификаторы

Но что будет, если применять разный цвет к одному элементу используя разные идентификаторы.

Как браузер понимает какой цвет применять. Все дело в специфичности селекторов, где она выше, тот селектор и будет применен.

Рассмотрим пример. В комментариях указана специфичность селектора. Какая выше тот стиль и будет применен.

````css
p#block { /*1.0.1*/
  background-color: #caac38;
}

#block { /*1.0.0*/
  background-color: #2bcc2b;
}

p { /*0.0.1*/
  background-color: #77AAEE;
}
````

````html
<p id="block">123</p>
````

Результирующим цветом будет цвет селектора `p#block`, так как он имеет наивысшую специфичность.

> Важно понимать, что идентификаторы чувствительны к регистру символов.
{: .prompt-info }

`id` элемента является глобальным свойством документа в `javascript`,через которое можно получить доступ к элементу.

Понимание специфичности, отдельная большая тема, которая рассматривается отдельно.

## Селектор класса (.)

В отличие от идентификаторов классы у разных элементов могут повториться. Классы нужны преимущественно для стилизации элемента.

В `html` они задаются в атрибуте `class`.

Точка `.` - это то что отличает элемент от класса.

### Пример 1. Базовое использование классов

Базовый пример типичного использования классов. Есть несколько разных элементов, нужно их стилизовать одним селектором.

````css
.one {
  background-color: #0d6efd;
}
````

````html
<header class="one">1</header>
<div class="one">2</div>
<small class="one">3</small>
````

В результате получаем что все элементы с классом `one` покрасятся в синий цвет.

Так же в сочетании с [универсальным селектором]() получается такой же результат

````css
*.one {
  background-color: #0d6efd;
}
````

### Пример 2. Класс в сочетании с элементом.

В рамках элемента можно сузить поиск, только элементы с определенным классом

````css
div.test {
  color: #2bcc2b;
}
````

````html
<div class="test">1</div>
<div class="test2">1</div>
<div class="test3">1</div>
````

Только цвет текста первого `div` попадет под влияние правила.

### Пример 3. Правило нескольких классов

Так как у элемента может быть несколько классов. В селекторе класса можно указать их несколько сразу.

Например 

````css
.test.test2 {
  color: #2bcc2b;
}
````

````html
<div class="test test2">1</div>
<div class="test">2</div>
<div class="test2">3</div>
````

В данном случае селектор будет применение только к первому элементу `div`, так как только у него есть сразу два класса `test test2`.

Два соседних элемента никак не будет выбраны.

> Благодаря гибкости классов их можно переиспользовать в различных сочетаниях. То есть получаем очень гибкий способ стилизации страниц любой сложности
{: .prompt-info }

### Пример 4. Вложенный класс

Поиск элементов вложенных друг в друга можно находить по их классам

````css
.test .test2 {
  color: #2bcc2b;
}
````

````html
<div class="test">
  <div class="test2">1</div>
</div>
<div class="test2">
  <div class="test1">2</div>
</div>
````

В результате селектор будет применение к первому `div` с последовательностью классов `.test .test2`

> Одну и туже задачу поиска элементов можно решить несколькими способами.
{: .prompt-info }

## Селектор по атрибуту (`[a]`)

Здесь важен вообще факт наличия атрибута, либо его значение.

Селекторы по атрибуту имеют различные вариации использования. И так же как и все остальные селекторы можно комбинировать.

### `[a]` наличие атрибута

Просто выбираем все элементы где есть указанный атрибут

#### Пример 1. Выбрать все элементы с атрибутом

````css
[translate] {
  background-color: darkcyan;
}
````

````html
<header translate="yes">header</header>
<div translate="no">div</div>
````

В данном случае будут выбраны два элемента, вне зависимости от значения атрибута

#### Пример 2. элемент с атрибутом

А теперь выберем элемент с определенным атрибутом

````css
header[translate] {
  background-color: darkcyan;
}
````

````html
<header translate="yes">header</header>
<div translate="no">div</div>
````

Здесь под условие подходит только элемент `header`.

### `[a=v]` `[a="v"]` точное значение атрибута

Селектор атрибута с точным его значением.

#### Пример 1. Базовое использование

````css
[title=test] {
  background-color: #0d6efd;
}
/* Или, что равнозначно*/
[title="test"] {
  background-color: #89c567;
}
````

````html
<header title="test">header</header>
<div title="test">div</div>
````

По сути эти два элемента имеют одно и то же значение тега, значит они подходят под условие

#### Пример 2. Тег с определенным значением атрибута

В этом примере, нам нужен только элемент `p`. Укажем его в селекторе

````css
p[title="test"] {
  background-color: #89c567;
}
````

````html
<header title="test">header</header>
<div title="test">div</div>
<p title="test">p</p>
````

В результате покрасится в цвет только элемент `p`.

Для консистентности значение лучше указывать в кавычках. 

#### Пример 3. Значение стиля

Так же ничего не мешает выбрать элементы по определенным значениям стиля. К примеру

````css
[style="display: block;"] {
  background-color: #89c567;
}
````

````html
<header style="display: block;">header</header>
<div style="display: block;">div</div>
<p style="display: block;">p</p>
````

### `[a~=v]` значение одного из слов

Здесь если в атрибуте несколько слов, то будет выбрано одно из значений.

#### Пример 1. Выбор класса

В примере мы выбрали только элементы, где в значение атрибута `class`, есть определенное значение.

````css
[class ~= "one"] {
  background-color: #89c567;
}
````

````html
<header class="one two">header</header>
<div class="two">div</div>
<p class="one two">p</p>
````

В данном случае будет выбран элемент `haeder` и `p`.

Можно сделать проще и просто выбрать класс `one`.

````css
.one {
  background-color: #89c567;
}
````

Результат будет такой же.

### `[a |= v]` значение = v либо = v-

Этот тип селектора атрибута выбирает значение равное выбранному или после него следует символ `-`.

#### Пример 1. Определенные элементы

````css
[class |= "two"] {
  background-color: #89c567;
}
````

````html
<header class="two-123">header</header>
<div class="two">div</div>
<p class="one two">p</p>
````

В примере только `header` и `div` попадают под селектор. 

Значение должно быть только одно (в элементе `p` два класса).

### `[a ^= v]` значение должно начинаться с v

Здесь значение атрибута должно начинаться `v`

#### Пример 1. Значение атрибута начинается с текста

````css
[class ^= "tw"] {
  background-color: #89c567;
}
````

````html
<header class="two123123123">header</header>
<div class="twosdfsfsfdsdf">div</div>
<p class="werwerwer">p</p>
````

В данном примере значение класса, чтобы попасть под селектор должно начинаться с `tw`, а это `header` и `div`.

### `[a $= v]` значение должно оканчиваться на v

Обратная ситуация, значение атрибута должно заканчиваться текстом.

#### Пример 1. Значение атрибута должно заканчиваться текстом

````css
[class $= "est"] {
  background-color: #89c567;
}
````

````html
<header class="test">header</header>
<div class="mest">div</div>
<p class="kerapa">p</p>
````

Под значение попадают элементы `header` и `div`, так как название их класса заканчивается на `est`.

### `[a *= v]` атрибут содержит в себе значение v

#### Пример 1. Значение атрибута содержится в тексте

````css
[title *= "success"] {
  background-color: #89c567;
}
````

````html
<div title="1success1">1</div>
<div title="uccess">2</div>
<div title="no-desigsuccesses">3</div>
````

В данном случае попадают только первый и третий `div`, так как они содержут в атрибуте `title` текст `success`.

#### Пример 2. Игнорирование регистра символов

Иногда бывает полезно, вообще игнорировать регистр. Для этого в конце селектора нужно добавить `i`.

````css
[title *= "success" i] {
  background-color: #89c567;
}
````

````html
<div title="success">1</div>
<div title="Success">2</div>
<div title="no-desigSuCcEsses">3</div>
````

В данном случае подходят все три элемента.

## Вложенный (потомков) селектор (E E)

Вложенный селектор или **селектор потомков** управляет вложенными элементами друг в друга. Правая часть селектора это родительские элементы, а последующие вложенные в них.

### Пример 1. Базовый пример вложенного селектора

````css
p span {
  background-color: #2bcc2b;
}
````

````html
<p>
  <span>span</span>
  <span>span</span>
</p>
````

Здесь понятно, элемент `span` должен быть сложен в `p`. В итоге попадают два элемента span.

Тут важно понимать, что элемент `span` может быть в `p` на любом уровне вложенности. Например

````html
<div>
  <div>
    <main>
      <header>
        <div>
          <p>
            <span>span</span>
            <span>span</span>
          </p>
        </div>
      </header>
    </main>
  </div>
</div>
````

Такая разметка тоже подходит.

### Пример 2. Большой уровень вложенности

Так же может быть сколь угодно большой уровень сложности селекторов

````css
div .one #main .my-div p .span {
  background-color: #818e81;
}
````

````html
<div>
  <div class="one two">
    <main id="main">
      <div class="my-div">
        <p>
          <span class="span">span</span>
        </p>
      </div>
      <div class="no-div"></div>
    </main>
  </div>
</div>
````

Например, под действие селектора попадает элемент `span` который мы и нашли по цепочке вложенных селекторов.

### Пример 3. Предок-потомок

````css
div p {
    color: red;
}
````

````html
<div>
  <p>Это дочерний элемент div.</p>
  <section>
    <p>Это вложенный элемент, но не прямой потомок div.</p>
  </section>
</div>
<p>Это элемент вне div.</p>
````

Подойдут первый `p` и вложенный `p` в `section`, так как они находятся на любом уровне вложенности от `div`.

## Соседний (смежный) селектор (E + E)

Если нужно управлять соседними элементами используется символ `+`. То есть элемент, который идет непосредственно за текущим.

### Пример 1. Простой пример смежных селекторов

В качестве простого примера, посмотрим на смежный селектор `p`.

````css
p + p {
  color: #f4bf75;
}
````

````html
<p>p1</p>
<small>small 1</small>
<p>p2</p>
<p>p3</p>
<p>p4</p>
````

В данном случае нам подойдут элементы `p3` и `p4` так как только они идут непосредственно за элементом `p`.

## Дочерний селектор (E > E)

Выбирает только те элементы которые являются непосредственно потомками указанного элемента.

### Пример 1. Пример дочернего селектора

````css
p > span {
  color: #f4bf75;
}
````

````html
<p>
  <span>span</span>
</p>
<span>span</span>
````

Здесь первый элемент `span` подходит только потому, что он является непосредственным потомком `p`.

### Пример 2. Родитель - ребенок

````css
div > p {
    color: red;
}
````

````html
<div>
  <p>Это дочерний элемент div.</p>
  <section>
    <p>Это вложенный элемент, но не прямой потомок div.</p>
  </section>
</div>
<p>Это элемент вне div.</p>
````

Под наше условие попадает только первый `p` вложенный в `div`, именно он непосредственный ребенок `div`.

### Пример 3. Прямой потомок

````css
.test > * {
  border-bottom: 1px double red;
  margin-bottom: 5px;
}
````

````html
<div class="test">
  <p>Прямой потомок 1</p>
  <div>Прямой потомок 2</div>
  <ul>
    <li>Не прямой потомок (внутри UL)</li>
    <li>Не прямой потомок (внутри UL)</li>
    <li>Не прямой потомок (внутри UL)</li>
    <li>Не прямой потомок (внутри UL)</li>
    <li>Не прямой потомок (внутри UL)</li>
  </ul>
</div>
````

Если внимательно посмотреть на разметку, можно увидеть закономерность, стиль применятся только к прямым потомкам ко всем элементам, а это
`p`, `div`, `ul`, то что внутри ul, элементы `li` под правило не подходят.

![Прямой потомок](/assets/img/posts/css/selectors/selector-1.png){: .shadow }
_Прямой потомок_

## Отличие дочернего (E > E) и смежного (E E) селектора

- Дочерний селектор (E > E) - это непосредственный потомок только одного уровня вложенности.
- Смежный селектор (E E) - это селектор любого потомка любого уровня вложенности.

### Пример 1. Показываем отличие на примере абзацев

````css
article > p {
  font-weight: bold;
}

article p {
  color: green;
}
````

````html
<article>
  <p>Этот абзац находится внутри article.</p>
  <div>
    <p>Этот абзац находится внутри div, который находится внутри article.</p>
  </div>
</article>
````

Здесь, благодаря смежному селектору оба абзаца будет зеленого цвета, а благодаря дочернему селектору только первый абзац будет жирным. 

## Родственный селектор (E ~ E)

Выбирает элементы, которые являются общими потомками одного родителя и следуют за ним.

### Пример 1. Использование селектора

````css
.test ~ div {
  background-color: #90a959;
}
````

````html
<div class="test">
  <div>test 1</div>
  <div>test 5</div>
</div>
<div>test 2</div>
<div>test 3</div>
<div>test 4</div>
````

В текущей расладке, под действие селектора попадают `div` элементы `test2, test3, test4`, так как эти элементы являются потомками одного родителя.

### Пример 2. Скрытие и показ элементов

Еще пример, на котором видно как можно это использовать.

````css
div,p {
  display: none;
}
#switch:checked ~ div {
  display: block;
}
````

````html
<form>
  <input type="checkbox" id="switch">
  <label for="switch">Показать</label>
  <p>p1</p>
  <p>p2</p>
  <p>p3</p>
  <div>div 1</div>
  <div>div 2</div>
  <div>div 3</div>
</form>
````

В примере форма, где все ее дочерние блоки по умолчанию скрыты, имеют `dispay:none`, но при клике на чекбокс, показываются только элементы `div`, несмотря на то, что в разметке так же есть элементы `p`.

> Пример того, что даже без javascript можно делать базовые манипуляции с элементами.
{: .prompt-info }

## Группировка селекторов (selector1,selector2)

Если есть селекторы, которым нужно задать одни и те-же правила, можно перечислить через запятую

````css
h1, h2, h3, h4, h5, h6 {
  background-color: #0a3069;
}
````

Селекторы могут быть любого типа и никак не связанными между собой.

> Рекомендуется переносить каждый селектор на новую строку
{: .prompt-info }

## Объединение селекторов (selector.selector[selector])

Атрибуты и классы которые содержат все правила сразу

````css
div.p.h[title="title"]{
  color: red;
}
````

````html
<div class="p h" title="title">div 1</div>
<div class="p g" title="title">div 2</div>
<div class="p h" title="title1">div 3</div>
<div class="p h" title="title">div 4</div>
````

В данном примере попадет `div1` и `div4` так как селектор полностью совпадает.

Стили будут применены только к элементам где будут все перечисленные селекторы.

## Кратко

Краткая справка по основным селекторам:

1. Универсальный селектор `*` - выбирает все селекторы на странице
   1. `+` Легко выбрать все элементы.
   2. `+` Стили применяются сразу ко всем элементам.
   3. `-` Скорость работы селектора может быть ниже.
   4. `-` Может применятся стили к элементам к которым не должны применятся из-за "могущества" селектора
   5. `* {color: #2bcc2b;}`
2. Селектор тега `selector` - позволяет выбрать все элементы с указанным тегом.
   1. `+` Стиль применятся ко всем элементам указанного типа на странице.
   2. `-` Стиль может быть применен глобально ко всем элементам, возможно это не то что нужно.
   3. `?` Селектор применим ко всем элементам на странице все зависимости от уровня вложенности.
   4. `?` Можно использовать в качестве отправной точки для стилизации элементов данного типа
   5. `div { color: #bcbecc;}`
3. Идентификатор `#selector` - выбор одного элемента на основе его атрибута `id`
   1. `+` Быстродействие, элемент по `id` будет найден быстро.
   2. `-` На странице может быть только один элемент с указанным `id`.
   3. `?` Возможны проблемы с переопределением селектора, рассмотрите другие варианты селектора.
   4. `#block { background-color: #caac38;}`.
4. Селектор класса `.selector` - выбор всех элементов с определенным классом
   1. `?` В основном используется для стилизации элементов, считается очень гибким элементом стилизации
   2. `+` Один и тот же класс можно применять сразу к нескольким элементам.
   3. `.class {background-color: #0d6efd;}`



Объединение двух и более селекторов .class1.class2
Потомки: .element1 .element2
Непосредственно вложенные: .element1 > .element2
Смежные: .element1 + .element2
Последующие: .element1 ~ .element2

## Комплексный пример

пишу его big




